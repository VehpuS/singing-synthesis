import React from "react";
import { useQueries } from "@tanstack/react-query";
import { every, indexOf, map, some } from "lodash";

// @ts-expect-error - This is an autogenerated file that will be overwritten or replaced by the build process
import createOddVoicesModule from "./js/oddvoices_wasm.mjs";
import { OddVoiceJSON } from "../oddVoiceJSON/oddVoiceHelpers";
import { Voice, allVoices, voiceUrlPrefix } from "./oddvoicesUtils";

interface VoiceObject {
    initFromFile: (filename: string) => void;
}

interface VoiceFactory {
    new (): VoiceObject;
}

export const useOddVoicesApp = () => {
    const [oddVoiceApp, setOddVoiceApp] = React.useState<{
        sing: (voice: VoiceObject, input: string, output: string, lyricsOverride: string) => string;
        FS: {
            readFile: (filename: string) => Uint8Array;
            writeFile: (filename: string, data: Uint8Array) => void;
            mkdir: (dirname: string) => void;
        };
        Voice: VoiceFactory;
    } | null>(null);

    React.useEffect(() => {
        const initialize = async () => {
            const newApp = await createOddVoicesModule();
            newApp?.FS.mkdir("/voices/");
            setOddVoiceApp(newApp);
        };
        initialize();
    }, []);

    const voiceQueries = useQueries({
        queries: map(allVoices, (activeVoice) => ({
            queryKey: ["oddVoices", activeVoice],
            queryFn: async () => {
                if (!oddVoiceApp || !activeVoice) {
                    return;
                }
                const response = await fetch(`${voiceUrlPrefix}${activeVoice}.voice`);
                const buffer = await response.arrayBuffer();

                const fileName = `/voices/${activeVoice}.voice`;
                oddVoiceApp.FS.writeFile(fileName, new Uint8Array(buffer));

                return buffer;
            },
            enabled: Boolean(oddVoiceApp && activeVoice),
            retry: false,
        })),
    });

    const generateVoiceFromOddVoiceJson =
        React.useRef<(oddVoiceJson: OddVoiceJSON, voice: Voice) => Uint8Array | undefined>();
    React.useEffect(() => {
        generateVoiceFromOddVoiceJson.current = (
            oddVoiceJson: OddVoiceJSON,
            voice: Voice = Voice.air
        ): Uint8Array | undefined => {
            if (!oddVoiceApp) {
                console.error("OddVoice app not initialized");
                return;
            }
            const voiceIndex = indexOf(allVoices, voice);
            if (voiceIndex === -1) {
                console.error(`Unsupported voice ${voice}`);
                return;
            }
            const voiceQuery = voiceQueries[voiceIndex];
            if (!voiceQuery.data) {
                console.error(`Voice not loaded: ${voice}`);
                return;
            }
            const activeVoice = allVoices[voiceIndex];
            const fileName = `/voices/${activeVoice}.voice`;

            const voiceData = new oddVoiceApp.Voice();
            voiceData.initFromFile(fileName);

            const error: string = oddVoiceApp.sing(voiceData, JSON.stringify(oddVoiceJson), "out.wav", "");
            if (error !== "") {
                console.error(error);
                return;
            }

            const buffer: Uint8Array = oddVoiceApp.FS.readFile("out.wav");
            if (!buffer || buffer.length === 0) {
                console.error("No buffer");
                return;
            }
            return buffer;
        };
    }, [oddVoiceApp, voiceQueries]);

    const voiceErrors = map(voiceQueries, (query) => query.error);
    if (some(voiceErrors)) {
        console.error(voiceErrors);
    }

    const isLoadingVoice = some(map(voiceQueries, (query) => query.isLoading));

    return {
        isLoadingApp: !oddVoiceApp,
        isLoadingVoice,
        generateVoiceFromOddVoiceJson,
        voiceLoadingFailed: !isLoadingVoice && !every(map(voiceQueries, (query) => Boolean(query.data))),
    };
};
